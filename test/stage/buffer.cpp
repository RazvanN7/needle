// Generated by llvm2cpp - DO NOT MODIFY!

#include <llvm/Pass.h>
#include <llvm/PassManager.h>
#include <llvm/ADT/SmallVector.h>
#include <llvm/Analysis/Verifier.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/CallingConv.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/GlobalVariable.h>
#include <llvm/IR/IRPrintingPasses.h>
#include <llvm/IR/InlineAsm.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/Module.h>
#include <llvm/Support/FormattedStream.h>
#include <llvm/Support/MathExtras.h>
#include <algorithm>
using namespace llvm;

Module *makeLLVMModule();

int main(int argc, char **argv) {
    Module *Mod = makeLLVMModule();
    verifyModule(*Mod, PrintMessageAction);
    PassManager PM;
    PM.add(createPrintModulePass(&outs()));
    PM.run(*Mod);
    return 0;
}

Module *makeLLVMModule() {
    // Module Construction
    Module *mod = new Module("buffer.bc", getGlobalContext());
    mod->setDataLayout("0x35a6840");
    mod->setTargetTriple("x86_64-unknown-linux-gnu");

    // Type Definitions
    ArrayType *ArrayTy_0 =
        ArrayType::get(IntegerType::get(mod->getContext(), 8), 96);

    PointerType *PointerTy_1 = PointerType::get(ArrayTy_0, 0);

    ArrayType *ArrayTy_2 =
        ArrayType::get(IntegerType::get(mod->getContext(), 8), 3);

    PointerType *PointerTy_3 = PointerType::get(ArrayTy_2, 0);

    std::vector<Type *> FuncTy_4_args;
    PointerType *PointerTy_5 =
        PointerType::get(IntegerType::get(mod->getContext(), 8), 0);

    FuncTy_4_args.push_back(PointerTy_5);
    FuncTy_4_args.push_back(PointerTy_5);
    FunctionType *FuncTy_4 = FunctionType::get(
        /*Result=*/IntegerType::get(mod->getContext(), 32),
        /*Params=*/FuncTy_4_args,
        /*isVarArg=*/false);

    PointerType *PointerTy_6 =
        PointerType::get(IntegerType::get(mod->getContext(), 64), 0);

    std::vector<Type *> FuncTy_7_args;
    FunctionType *FuncTy_7 = FunctionType::get(
        /*Result=*/IntegerType::get(mod->getContext(), 32),
        /*Params=*/FuncTy_7_args,
        /*isVarArg=*/false);

    PointerType *PointerTy_8 = PointerType::get(FuncTy_4, 0);

    std::vector<Type *> FuncTy_10_args;
    FuncTy_10_args.push_back(PointerTy_5);
    FunctionType *FuncTy_10 = FunctionType::get(
        /*Result=*/IntegerType::get(mod->getContext(), 32),
        /*Params=*/FuncTy_10_args,
        /*isVarArg=*/true);

    PointerType *PointerTy_9 = PointerType::get(FuncTy_10, 0);

    // Function Declarations

    Function *func___prev_store_exists =
        mod->getFunction("__prev_store_exists");
    if (!func___prev_store_exists) {
        func___prev_store_exists = Function::Create(
            /*Type=*/FuncTy_4,
            /*Linkage=*/GlobalValue::ExternalLinkage,
            /*Name=*/"__prev_store_exists", mod);
        func___prev_store_exists->setCallingConv(CallingConv::C);
    }
    AttributeSet func___prev_store_exists_PAL;
    {
        SmallVector<AttributeSet, 4> Attrs;
        AttributeSet PAS;
        {
            AttrBuilder B;
            B.addAttribute(Attribute::ReadNone);
            PAS = AttributeSet::get(mod->getContext(), 1U, B);
        }

        Attrs.push_back(PAS);
        {
            AttrBuilder B;
            B.addAttribute(Attribute::ReadOnly);
            PAS = AttributeSet::get(mod->getContext(), 2U, B);
        }

        Attrs.push_back(PAS);
        {
            AttrBuilder B;
            B.addAttribute(Attribute::NoUnwind);
            B.addAttribute(Attribute::ReadOnly);
            B.addAttribute(Attribute::NoInline);
            B.addAttribute(Attribute::UWTable);
            PAS = AttributeSet::get(mod->getContext(), ~0U, B);
        }

        Attrs.push_back(PAS);
        func___prev_store_exists_PAL =
            AttributeSet::get(mod->getContext(), Attrs);
    }
    func___prev_store_exists->setAttributes(func___prev_store_exists_PAL);

    Function *func_main = mod->getFunction("main");
    if (!func_main) {
        func_main = Function::Create(
            /*Type=*/FuncTy_7,
            /*Linkage=*/GlobalValue::ExternalLinkage,
            /*Name=*/"main", mod);
        func_main->setCallingConv(CallingConv::C);
    }
    AttributeSet func_main_PAL;
    {
        SmallVector<AttributeSet, 4> Attrs;
        AttributeSet PAS;
        {
            AttrBuilder B;
            B.addAttribute(Attribute::NoUnwind);
            B.addAttribute(Attribute::NoInline);
            B.addAttribute(Attribute::UWTable);
            PAS = AttributeSet::get(mod->getContext(), ~0U, B);
        }

        Attrs.push_back(PAS);
        func_main_PAL = AttributeSet::get(mod->getContext(), Attrs);
    }
    func_main->setAttributes(func_main_PAL);

    Function *func_printf = mod->getFunction("printf");
    if (!func_printf) {
        func_printf = Function::Create(
            /*Type=*/FuncTy_10,
            /*Linkage=*/GlobalValue::ExternalLinkage,
            /*Name=*/"printf", mod); // (external, no body)
        func_printf->setCallingConv(CallingConv::C);
    }
    AttributeSet func_printf_PAL;
    {
        SmallVector<AttributeSet, 4> Attrs;
        AttributeSet PAS;
        {
            AttrBuilder B;
            B.addAttribute(Attribute::ReadOnly);
            B.addAttribute(Attribute::NoCapture);
            PAS = AttributeSet::get(mod->getContext(), 1U, B);
        }

        Attrs.push_back(PAS);
        {
            AttrBuilder B;
            B.addAttribute(Attribute::NoUnwind);
            PAS = AttributeSet::get(mod->getContext(), ~0U, B);
        }

        Attrs.push_back(PAS);
        func_printf_PAL = AttributeSet::get(mod->getContext(), Attrs);
    }
    func_printf->setAttributes(func_printf_PAL);

    // Global Variable Declarations

    GlobalVariable *gvar_array_undo_log = new GlobalVariable(
        /*Module=*/*mod,
        /*Type=*/ArrayTy_0,
        /*isConstant=*/false,
        /*Linkage=*/GlobalValue::CommonLinkage,
        /*Initializer=*/0, // has initializer, specified below
        /*Name=*/"undo_log");
    gvar_array_undo_log->setAlignment(16);

    GlobalVariable *gvar_array__str = new GlobalVariable(
        /*Module=*/*mod,
        /*Type=*/ArrayTy_2,
        /*isConstant=*/true,
        /*Linkage=*/GlobalValue::PrivateLinkage,
        /*Initializer=*/0, // has initializer, specified below
        /*Name=*/".str");
    gvar_array__str->setAlignment(1);

    // Constant Definitions
    ConstantAggregateZero *const_array_11 =
        ConstantAggregateZero::get(ArrayTy_0);
    Constant *const_array_12 =
        ConstantDataArray::getString(mod->getContext(), "%d", true);
    ConstantInt *const_int64_13 =
        ConstantInt::get(mod->getContext(), APInt(64, StringRef("-16"), 10));
    ConstantInt *const_int32_14 =
        ConstantInt::get(mod->getContext(), APInt(32, StringRef("1"), 10));
    ConstantInt *const_int32_15 =
        ConstantInt::get(mod->getContext(), APInt(32, StringRef("0"), 10));
    ConstantInt *const_int64_16 =
        ConstantInt::get(mod->getContext(), APInt(64, StringRef("1639"), 10));
    Constant *const_ptr_17 = ConstantExpr::getCast(
        Instruction::BitCast, gvar_array_undo_log, PointerTy_6);
    ConstantInt *const_int64_18 =
        ConstantInt::get(mod->getContext(), APInt(64, StringRef("1638"), 10));
    std::vector<Constant *> const_ptr_20_indices;
    ConstantInt *const_int64_21 =
        ConstantInt::get(mod->getContext(), APInt(64, StringRef("0"), 10));
    const_ptr_20_indices.push_back(const_int64_21);
    ConstantInt *const_int64_22 =
        ConstantInt::get(mod->getContext(), APInt(64, StringRef("32"), 10));
    const_ptr_20_indices.push_back(const_int64_22);
    Constant *const_ptr_20 = ConstantExpr::getGetElementPtr(
        gvar_array_undo_log, const_ptr_20_indices);
    Constant *const_ptr_19 =
        ConstantExpr::getCast(Instruction::BitCast, const_ptr_20, PointerTy_6);
    std::vector<Constant *> const_ptr_23_indices;
    const_ptr_23_indices.push_back(const_int64_21);
    const_ptr_23_indices.push_back(const_int64_21);
    Constant *const_ptr_23 = ConstantExpr::getGetElementPtr(
        gvar_array_undo_log, const_ptr_23_indices);
    std::vector<Constant *> const_ptr_24_indices;
    const_ptr_24_indices.push_back(const_int64_21);
    const_ptr_24_indices.push_back(const_int64_21);
    Constant *const_ptr_24 =
        ConstantExpr::getGetElementPtr(gvar_array__str, const_ptr_24_indices);

    // Global Variable Definitions
    gvar_array_undo_log->setInitializer(const_array_11);
    gvar_array__str->setInitializer(const_array_12);

    // Function Definitions

    // Function: __prev_store_exists (func___prev_store_exists)
    {
        Function::arg_iterator args = func___prev_store_exists->arg_begin();
        Value *ptr_begin = args++;
        ptr_begin->setName("begin");
        Value *ptr_loc = args++;
        ptr_loc->setName("loc");

        BasicBlock *label_entry = BasicBlock::Create(
            mod->getContext(), "entry", func___prev_store_exists, 0);
        BasicBlock *label_while_cond = BasicBlock::Create(
            mod->getContext(), "while.cond", func___prev_store_exists, 0);
        BasicBlock *label_while_body = BasicBlock::Create(
            mod->getContext(), "while.body", func___prev_store_exists, 0);
        BasicBlock *label_return = BasicBlock::Create(
            mod->getContext(), "return", func___prev_store_exists, 0);

        // Block entry (label_entry)
        CastInst *ptr_25 =
            new BitCastInst(ptr_loc, PointerTy_6, "", label_entry);
        BranchInst::Create(label_while_cond, label_entry);

        // Block while.cond (label_while_cond)
        Argument *fwdref_27 = new Argument(PointerTy_5);
        PHINode *ptr_loc_pn =
            PHINode::Create(PointerTy_5, 2, "loc.pn", label_while_cond);
        ptr_loc_pn->addIncoming(ptr_loc, label_entry);
        ptr_loc_pn->addIncoming(fwdref_27, label_while_body);

        GetElementPtrInst *ptr_curr_0 = GetElementPtrInst::Create(
            ptr_loc_pn, const_int64_13, "curr.0", label_while_cond);
        ICmpInst *int1_cmp = new ICmpInst(*label_while_cond, ICmpInst::ICMP_ULT,
                                          ptr_curr_0, ptr_begin, "cmp");
        BranchInst::Create(label_return, label_while_body, int1_cmp,
                           label_while_cond);

        // Block while.body (label_while_body)
        CastInst *ptr_29 =
            new BitCastInst(ptr_curr_0, PointerTy_6, "", label_while_body);
        LoadInst *int64_30 = new LoadInst(ptr_29, "", false, label_while_body);
        int64_30->setAlignment(8);
        LoadInst *int64_31 = new LoadInst(ptr_25, "", false, label_while_body);
        int64_31->setAlignment(8);
        ICmpInst *int1_cmp1 = new ICmpInst(*label_while_body, ICmpInst::ICMP_EQ,
                                           int64_30, int64_31, "cmp1");
        BranchInst::Create(label_return, label_while_cond, int1_cmp1,
                           label_while_body);

        // Block return (label_return)
        PHINode *int32_retval_0 =
            PHINode::Create(IntegerType::get(mod->getContext(), 32), 2,
                            "retval.0", label_return);
        int32_retval_0->addIncoming(const_int32_14, label_while_body);
        int32_retval_0->addIncoming(const_int32_15, label_while_cond);

        ReturnInst::Create(mod->getContext(), int32_retval_0, label_return);

        // Resolve Forward References
        fwdref_27->replaceAllUsesWith(ptr_curr_0);
        delete fwdref_27;
    }

    // Function: main (func_main)
    {

        BasicBlock *label_entry_34 =
            BasicBlock::Create(mod->getContext(), "entry", func_main, 0);

        // Block entry (label_entry_34)
        StoreInst *void_35 =
            new StoreInst(const_int64_16, const_ptr_17, false, label_entry_34);
        void_35->setAlignment(16);
        StoreInst *void_36 =
            new StoreInst(const_int64_18, const_ptr_19, false, label_entry_34);
        void_36->setAlignment(16);
        std::vector<Value *> int32_call_params;
        int32_call_params.push_back(const_ptr_23);
        int32_call_params.push_back(const_ptr_20);
        CallInst *int32_call =
            CallInst::Create(func___prev_store_exists, int32_call_params,
                             "call", label_entry_34);
        int32_call->setCallingConv(CallingConv::C);
        int32_call->setTailCall(true);
        AttributeSet int32_call_PAL;
        int32_call->setAttributes(int32_call_PAL);

        std::vector<Value *> int32_call4_params;
        int32_call4_params.push_back(const_ptr_24);
        int32_call4_params.push_back(int32_call);
        CallInst *int32_call4 = CallInst::Create(
            func_printf, int32_call4_params, "call4", label_entry_34);
        int32_call4->setCallingConv(CallingConv::C);
        int32_call4->setTailCall(true);
        AttributeSet int32_call4_PAL;
        {
            SmallVector<AttributeSet, 4> Attrs;
            AttributeSet PAS;
            {
                AttrBuilder B;
                B.addAttribute(Attribute::NoUnwind);
                PAS = AttributeSet::get(mod->getContext(), ~0U, B);
            }

            Attrs.push_back(PAS);
            int32_call4_PAL = AttributeSet::get(mod->getContext(), Attrs);
        }
        int32_call4->setAttributes(int32_call4_PAL);

        ReturnInst::Create(mod->getContext(), const_int32_15, label_entry_34);
    }

    return mod;
}
